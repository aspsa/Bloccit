# Assignment #52 - Intro to RSpec
#
# Since the intent for Test-Driven Development is to keep the tests as low-level as possible, the idea is to remove any dependencies to other Models. I assume this is a best practice. I also assume that if one referenced another model (e.g., the 'Post' model), that this RSpec file would have to somehow import the 'Post' RSpec file. Since this dependency is not asserted, then I assume it is sufficient to only require 'rails_helper' for RSpec testing purposes.
=begin
require 'rails_helper'

describe Vote do
describe "validations" do
       # Assignment #52 - Intro to RSpec
       #
       # I added an underscore to 'value validation' in order to follow the proper naming convention. Also, I assume that this functionality is best built in as an instance method and not as a class method, which is why the method name is preceded with a hash symbol. One assumes the 'Vote' model will be instantiated and assigned to an object instance variable. As with the 'Post' model RSpec test, perhaps this would be done in a 'before' block, as in the following example.
       #
       # before do
       #    @vote = Vote.create(value_validation: 0)
       # end
       #
       # Given the checkpoint's discussion on 'Red, Green, Refactor', I assume the 'Vote' object instance variable should hold a reference to a 'Vote' object that has a 'value_validation' value that initially intensionally fails the '#value_validation' RSpec test.
       describe "#value_validation" do
           it "only allows -1 or 1 as values" do
               expect( @vote.value_validation ).to eq(-1)
               expect( @vote.value_validation ).to eq(1)
           end
       end
    end
end
=end

# Assignment #52 - Intro to RSpec
#
# Dalibor's comments:
#      - You need to enter specific expectations in your tests. One of the possible solutions:
#
# Checkpoint #53 - Voting
#
# Create a Vote model with attributes for value (an integer), 'user_id' and 'post_id'.
#
# Hint: Use 'user:references' and 'post:references' in your generator to add the IDs and the relevant relationships in the model files.
#
# Note:  This file was autogenerated when the Vote model and migration file was created. However, the Checkpoint #53 - Voting refers back to the Vote RSpec model creating in Checkpoint #52 - Intro to RSpec. Therefore, I backed up this auto-generated Vote RSpec file ('vote_spec.rb_BAK') in favor of using the existing 'vote_spec.rb' file.

# Checkpoint #53 - Voting
#
# If you copied our test scaffold verbatim, you should get an uninitialized constant Vote (NameError) error. This error is because we forgot to require rails_helper, which tells our spec where to look for its associated models. Add that now.
require 'rails_helper'

describe Vote do
  # Checkoint #54 - Mocking with RSpec
  #
  # Remove the two factories from spec/models/post_spec.rb, and add them to this file (i.e., spec/support/test_factories.rb).
  #
  # Because we're removing the factories from post_spec.rb, we need to include the TestFactories module there as well. We should also replace our associated_post definition in vote_spec.rb. Follow the pattern of the votes_controller_spec above.
  include TestFactories

  describe "validations" do
    it "only allows -1 or 1 as values" do
      up_vote = Vote.new(value: 1)
      # Checkpoint #53 - Voting
      #
      # Dalibor's comments:
      #     - I checked out branch from github. I needed to add vote validation
      #       and use different rspec matcher to get the same output.
      #     - Enter the same corrections as above, and it should work.
      #
      #expect(up_vote.valid?).to be_true
      expect(up_vote).to be_valid
      
      down_vote = Vote.new(value: -1)
      # Checkpoint #53 - Voting
      #
      # Dalibor's comments:
      #     - I checked out branch from github. I needed to add vote validation
      #       and use different rspec matcher to get the same output.
      #     - Enter the same corrections as above, and it should work.
      #
      #expect(down_vote.valid?).to be_true
      expect(down_vote).to be_valid
      
      invalid_vote = Vote.new(value: 2)
      # Checkpoint #53 - Voting
      #
      # Dalibor's comments:
      #     - I checked out branch from github. I needed to add vote validation
      #       and use different rspec matcher to get the same output.
      #     - Enter the same corrections as above, and it should work.
      #
      #expect(invalid_vote.valid?).to be_false
      expect(invalid_vote).to be_invalid
    end
  end
  
  # Checkpoint #54 - Mocking with RSpec
  #
  # Let's use doubles to test our new post ranking system. As you recall, when a vote is saved, an after_save method, update_post, is called, and that method calls post.update_rank.
  #
  # Remember two of our testing principles, "respect object limits", and "test what, not how". We'll be following these principles closely in these tests. Specifically, in our vote_spec, we'll test that each vote sends a Post#update_rank "message" when saved, but not how that Post#update_rank method works, or how a vote is responsible for sending that message to its post.
  #
  # In other words, we're testing that the post receives the message, but not how it functions internally. If we want to test that functionality, we should do so in post_spec.rb.
  #
  # You'll note that we use the associated_post factory again. For now, just copy that method to the bottom of vote_spec.rb. We'll DRY things up soon.
  describe 'after_save' do
    it "calls 'Post#update_rank' after save" do
      post = associated_post
      vote = Vote.new(value: 1, post: post)
      expect(post).to receive(:update_rank)
      
      # Checkpoint #54 - Mocking with RSpec
      #
      # Note that we trigger the behavior after we set the expectation. That's because this is a behavior test, not a results test. In order for the test to look for this behavior, we have to set our expectation before we make it occur.
      vote.save
    end
  end
end